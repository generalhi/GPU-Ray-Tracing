#pragma kernel CSMain

static const float PI = 3.14159265f;

RWTexture2D<float4> Result;

float4x4 World;
float4x4 Projection;

Texture2D<float4> SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

float Time;
int ReflectionsCount;

struct Ray
{
    float3 Position;
    float3 Direction;
    float3 Energy;
};

Ray InitRay(float3 position, float3 direction)
{
    Ray r;
    r.Position = position;
    r.Direction = direction;
    r.Energy = 1.0;
    return r;
}

struct RayHit
{
    float3 Position;
    float Distance;
    float3 Normal;
};

RayHit InitRayHit()
{
    RayHit hit;
    hit.Position = 0.0;
    hit.Distance = 1.#INF;
    hit.Normal = 0.0;
    return hit;
}

Ray InitCameraRay(float2 uv)
{
    float3 position = mul(World, float4(0.0, 0.0, 0.0, 1.0)).xyz;
    float3 direction = mul(Projection, float4(uv, 0.0, 1.0)).xyz;

    direction = mul(World, float4(direction, 0.0)).xyz;
    direction = normalize(direction);

    return InitRay(position, direction);
}

void IntersectsGroundPlane(Ray ray, inout RayHit hit)
{
    float d = -ray.Position.y / ray.Direction.y;
    if (d > 0.0 &&
        d < hit.Distance)
    {
        hit.Position = ray.Position + d * ray.Direction;
        hit.Distance = d;
        hit.Normal = float3(0.0, 1.0, 0.0);
    }
}

void IntersectsSphere(Ray ray, inout RayHit hit, float4 sphere)
{
    float3 v = ray.Position - sphere.xyz;
    float p1 = -dot(ray.Direction, v);
    float p2sqr = p1 * p1 - dot(v, v) + sphere.w * sphere.w;
    if (p2sqr < 0.0)
    {
        return;
    }
    float p2 = sqrt(p2sqr);
    float d = p1 - p2 > 0.0
                  ? p1 - p2
                  : p1 + p2;
    if (d > 0.0 &&
        d < hit.Distance)
    {
        hit.Position = ray.Position + d * ray.Direction;
        hit.Distance = d;
        hit.Normal = normalize(hit.Position - sphere.xyz);
    }
}

RayHit Trace(Ray ray)
{
    RayHit hit = InitRayHit();
    IntersectsGroundPlane(ray, hit);
    IntersectsSphere(ray, hit, float4(0.0, 1.2, 0.0, 1.0));
    return hit;
}

float3 SkyBoxColor(inout Ray ray)
{
    ray.Energy = 0.0;
    float phi = atan2(ray.Direction.x, -ray.Direction.z) / -PI * 0.5;
    float theta = acos(ray.Direction.y) / -PI;
    return SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, float2(phi, theta), 0.0).xyz;
}

float3 Shade(inout Ray ray, RayHit hit)
{
    //if (hit.Distance < 1.#INF)
    if (hit.Distance > 0.0)
    {
        float3 specular = 0.8;

        ray.Position = hit.Position + hit.Normal * 0.001;
        ray.Direction = reflect(ray.Direction, hit.Normal);
        ray.Energy *= specular;
        //return hit.Normal * 0.5 + 0.5;
        return 0.0;
    }
    else
    {
        return SkyBoxColor(ray);
    }
}

float4 MainRaytracing(uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);
    float2 uv = id.xy / float2(w, h) * 2.0 - 1.0;

    Ray ray = InitCameraRay(uv);
    float3 result = 0.0; // Shade(ray, hit);

    for (int i = 0; i < ReflectionsCount; i++)
    {
        RayHit hit = Trace(ray);
        result += ray.Energy * Shade(ray, hit);

        if (!any(ray.Energy))
        {
            break;
        }
    }

    //Result[id.xy] = float4(uv, 0, 1);
    return float4(result, 1.0);
}

// --- Raymarching -------------------------------------------------------------------------
float SdSphere(float3 p, float s)
{
    return length(p) - s;
}

float SdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float SmoothMin(float a, float b, float k)
{
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * h * (1.0 / 6.0);
}

float2 SmoothMin2(float a, float b, float k)
{
    k *= 6.0;
    float h = max(k - abs(a - b), 0.0) / k;
    float m = h * h * h * 0.5;
    float s = m * k * (1.0 / 3.0);
    return a < b
               ? float2(a - s, m)
               : float2(b - s, 1.0 - m);
}

float3 DeltaSin(float speed, float3 axis)
{
    return axis * sin(Time * speed);
}

float3 Move(float3 position, float3 delta)
{
    return position + delta;
}

float3 Rotation(float3 p, float3 axis, float angle)
{
    return lerp(dot(axis, p) * axis, p, cos(angle))
        + cross(axis, p) * sin(angle);
}

float2 Map(float3 position)
{
    //float3 deltaPosition = float3(sin(Time * 0.3) * 3.0, 0.0, 0.0);
    //float sphere = SdSphere(position - deltaPosition);
    float sphere = SdSphere(Move(position, DeltaSin(1.0, float3(2.5, 0.0,0.0))), 0.9);

    float3 pBox = position;
    pBox = Move(position, DeltaSin(1.0, float3(0.0, 1.0,0.0)));
    pBox = Rotation(pBox, float3(0.0, 0.0, 1.0), Time * 0.5);
    pBox = Rotation(pBox, float3(1.0, 0.0, 0.0), Time * 1.0);
    float box = SdBox(pBox, 0.5);
    float ground = position.y + 0.5;
    //return SmoothMin(ground, SmoothMin(sphere, box, 2.0), 1.0);
    return SmoothMin2(ground, SmoothMin2(sphere, box, 0.2), 0.05);
}

float3 CalcNormal(in float3 pos)
{
    float2 e = float2(1.0, -1.0) * 0.5773 * 0.005;
    return normalize(
        e.xyy * Map(pos + e.xyy).x +
        e.yyx * Map(pos + e.yyx).x +
        e.yxy * Map(pos + e.yxy).x +
        e.xxx * Map(pos + e.xxx).x);
}

RayHit RaymarchingTrace(Ray ray)
{
    const float MaxDistance = 10.0;
    RayHit hit = InitRayHit();
    hit.Distance = 0.0;

    for (int i = 0; i < 512; i++)
    {
        hit.Position = ray.Position + ray.Direction * hit.Distance;
        float distance = Map(hit.Position);
        if (distance < 0.0 ||
            hit.Distance > MaxDistance)
        {
            break;
        }

        hit.Distance += distance;
    }

    if (hit.Distance > MaxDistance)
    {
        hit.Distance = -1.0;
    }
    else
    {
        hit.Normal = CalcNormal(hit.Position);
    }

    return hit;
}

float4 MainRaymarching(uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);
    float2 uvr = (id.xy * 2.0 - float2(w, h)) / h;

    Ray ray = InitRay(float3(0.0, 0.0, -3.0), normalize(float3(uvr, 1.0)));
    float3 color = 0.0;

    for (int i = 0; i < ReflectionsCount; i++)
    {
        RayHit hit = RaymarchingTrace(ray);
        color += ray.Energy * Shade(ray, hit);

        if (!any(ray.Energy))
        {
            break;
        }
    }

    /*
    if (hit.Distance > 0)
    {
        float3 position = ray.Position + ray.Direction * hit.Distance;
        float3 normal = calcNormal(position);
        
        color = hit.Distance * 0.1;
    }
    else
    {
        color = SkyBoxColor(ray);
    }
    */

    return float4(color, 1.0);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 1.0);

    //Result[id.xy] = MainRaytracing(id);
    Result[id.xy] = MainRaymarching(id);
}
