#pragma kernel CSMain

static const float PI = 3.14159265f;

RWTexture2D<float4> Result;

float4x4 World;
float4x4 Projection;

Texture2D<float4> SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

float Time;
int ReflectionsCount;

struct Ray
{
    float3 Position;
    float3 Direction;
    float3 Energy;
};

Ray InitRay(float3 position, float3 direction)
{
    Ray r;
    r.Position = position;
    r.Direction = direction;
    r.Energy = 1.0;
    return r;
}

struct RayHit
{
    float3 Position;
    float Distance;
    float3 Normal;
};

RayHit InitRayHit()
{
    RayHit hit;
    hit.Position = 0.0;
    hit.Distance = 1.#INF;
    hit.Normal = 0.0;
    return hit;
}

Ray InitCameraRay(float2 uv)
{
    float3 position = mul(World, float4(0.0, 0.0, 0.0, 1.0)).xyz;
    float3 direction = mul(Projection, float4(uv, 0.0, 1.0)).xyz;

    direction = mul(World, float4(direction, 0.0)).xyz;
    direction = normalize(direction);

    return InitRay(position, direction);
}

void IntersectsGroundPlane(Ray ray, inout RayHit hit)
{
    float d = -ray.Position.y / ray.Direction.y;
    if (d > 0.0 &&
        d < hit.Distance)
    {
        hit.Position = ray.Position + d * ray.Direction;
        hit.Distance = d;
        hit.Normal = float3(0.0, 1.0, 0.0);
    }
}

void IntersectsSphere(Ray ray, inout RayHit hit, float4 sphere)
{
    float3 v = ray.Position - sphere.xyz;
    float p1 = -dot(ray.Direction, v);
    float p2sqr = p1 * p1 - dot(v, v) + sphere.w * sphere.w;
    if (p2sqr < 0.0)
    {
        return;
    }
    float p2 = sqrt(p2sqr);
    float d = p1 - p2 > 0.0
                  ? p1 - p2
                  : p1 + p2;
    if (d > 0.0 &&
        d < hit.Distance)
    {
        hit.Position = ray.Position + d * ray.Direction;
        hit.Distance = d;
        hit.Normal = normalize(hit.Position - sphere.xyz);
    }
}

RayHit Trace(Ray ray)
{
    RayHit hit = InitRayHit();
    IntersectsGroundPlane(ray, hit);
    IntersectsSphere(ray, hit, float4(0.0, 1.2, 0.0, 1.0));
    return hit;
}

float3 Shade(inout Ray ray, RayHit hit)
{
    if (hit.Distance < 1.#INF)
    {
        float3 specular = 0.8;

        ray.Position = hit.Position + hit.Normal * 0.001;
        ray.Direction = reflect(ray.Direction, hit.Normal);
        ray.Energy *= specular;
        //return hit.Normal * 0.5 + 0.5;
        return 0.0;
    }
    else
    {
        ray.Energy = 0.0;

        float phi = atan2(ray.Direction.x, -ray.Direction.z) / -PI * 0.5;
        float theta = acos(ray.Direction.y) / -PI;
        return SkyBoxTexture.SampleLevel(sampler_SkyBoxTexture, float2(phi, theta), 0.0).xyz;
    }
}

float4 MainRaytracing(uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);
    float2 uv = id.xy / float2(w, h) * 2.0 - 1.0;

    Ray ray = InitCameraRay(uv);
    float3 result = 0.0; // Shade(ray, hit);

    for (int i = 0; i < ReflectionsCount; i++)
    {
        RayHit hit = Trace(ray);
        result += ray.Energy * Shade(ray, hit);

        if (!any(ray.Energy))
        {
            break;
        }
    }

    //Result[id.xy] = float4(uv, 0, 1);
    return float4(result, 1.0);
}

// Raymarching
float sdSphere(float3 p)
{
    return length(p) - 1.0;
}

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float SmoothMin(float a, float b, float k)
{
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * h * (1.0 / 6.0);
}

float3 Rotation(float3 p, float3 axis, float angle)
{
    return lerp(dot(axis, p) * axis, p, cos(angle))
        + cross(axis, p) * sin(angle);
}

float RaymarchingSphere(float3 position)
{
    float3 deltaPosition = float3(sin(Time) * 3.0, 0.0, 0.0);
    float sphere = sdSphere(position - deltaPosition);

    float3 pBox = Rotation(position, float3(0.0, 0.0, 1.0), Time);
    pBox = Rotation(pBox, float3(1.0, 0.0, 0.0), Time * 0.1);
    float box = sdBox(pBox, 0.5);
    float ground = position.y + 0.5;
    return SmoothMin(ground, SmoothMin(sphere, box, 2.0), 1.0);
}

float4 MainRaymarching(uint3 id : SV_DispatchThreadID)
{
    uint w, h;
    Result.GetDimensions(w, h);
    float2 uvr = (id.xy * 2.0 - float2(w, h)) / h;

    Ray ray = InitRay(float3(0.0, 0.0, -3.0), normalize(float3(uvr, 1.0)));
    float3 color = 0.0;
    float t = 0.0;

    for (int i = 0; i < 80.0; i++)
    {
        float3 p = ray.Position + ray.Direction * t;
        float d = RaymarchingSphere(p);
        t += d;

        if (d < 0.001 ||
            t > 100.0)
        {
            break;
        }
    }

    color = t * 0.1;
    return float4(color, 1.0);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 1.0);

    //Result[id.xy] = MainRaytracing(id);
    Result[id.xy] = MainRaymarching(id);
}
